@page "/admin/drive/"
@using System.Linq
@using Blogifier.Admin.Components.Drive;
@using Models
@using Serivces
@inject IStringLocalizer<Resource> _localizer

<div class="container">
    <h1 class="section-title">@_localizer["Drive"]</h1>
    <div class="section-content">
        <p>
            <label>
                <InputFile class="form-control" OnChange="@OnInputFileChange" multiple />
            </label>
        </p>

        @if (_filesToUpload != null && _filesToUpload.Count() > 0)
        {
            <ul class="list-group" aria-label="files">
                <Virtualize Items="_filesToUpload" Context="file">
                    <li class="list-group-item upload-file-item">
                        <FileComponent File="file.Value.FileModel" UploadState="file.Value.UploadState" OnDelete="(id) => RemoveUploadFile(file)"></FileComponent>
                    </li>
                </Virtualize>
            </ul>
        }

        @if (_files != null && _files.Count() > 0)
        {
            <ul class="list-group" aria-label="files">
                <Virtualize Items="_files" Context="file">
                    <li class="list-group-item">
                        <FileComponent File="file" OnDelete="(id) => RemoveFile(file)"></FileComponent>
                    </li>
                </Virtualize>
            </ul>
            <PagerComponent PagingDescriptor="_fileSearchModel.PagingDescriptor" OnPageChanged="@OnPageChanged" />
        }
    </div>
</div>

@code {
    [Inject]
    protected IFileService FileService { get; set; }
    [Inject]
    protected IUploadFileService UploadFileService { get; set; }

    private IList<FileModel> _files;
    private FileSearchModel _fileSearchModel = new();
    private System.Collections.Concurrent.ConcurrentDictionary<string, UploadFileModel> _filesToUpload = new();
    private int _maxAllowedFiles = 100;

    protected override async Task OnInitializedAsync()
    {
        await LoadAsync();
    }

    private async Task LoadAsync()
    {
        var result = await FileService.GetListAsync(_fileSearchModel);
        _fileSearchModel.PagingDescriptor.SetTotalCount(result.PagingDescriptor.TotalCount);
        _files = result.Results;
        StateHasChanged();
    }

    private void RemoveFile(FileModel model)
    {
        if (model != null)
        {
            _files.Remove(model);
        }
    }

    private void RemoveUploadFile(KeyValuePair<string, UploadFileModel> entry)
    {
        _filesToUpload.TryRemove(entry);
    }

    private async Task OnPageChanged(int pageNumber)
    {
        await LoadAsync();
    }

    private async Task OnInputFileChange(InputFileChangeEventArgs e)
    {
        try
        {
            var files = e.GetMultipleFiles(_maxAllowedFiles);
            var distinctFiles = files.Where(f => !_filesToUpload.ContainsKey(f.Name));
            var uploadFileModels = await UploadFileService.SetupNewFilesAsync(distinctFiles, uploadFileModel =>
            {
                if (!_filesToUpload.TryAdd(uploadFileModel.FileModel.Filename, uploadFileModel))
                {
                    uploadFileModel.FileModel.IsSuccessful = false;
                    uploadFileModel.FileModel.Message = "File upload failed";
                }
            });

            var uploadFileModelsAsync = UploadFileService.GetUploadFileModelsAsync(uploadFileModels.AsReadOnly());
            await uploadFileModelsAsync.AsyncParallelForEach(model => UploadFileService.UploadWithSignedUrlAsync(model, () => StateHasChanged()), 5);
        }
        catch(Exception)
        {
            //
        }
    }

}
